---
title: "biostats776-Project2"
author: "Zhengting (Johnathan) He"
date: "2021/9/27"
output: html_document
---

```{r "setup", include = FALSE}
require("knitr")
opts_knit$set(root.dir = "D:/OneDrive - Johns Hopkins/Course/140.776.71 - Statistical Computing/project/Project 2/biostats776-Project2")
```

```{r, message = FALSE}
# Set working directory and load packages
setwd("D:/OneDrive - Johns Hopkins/Course/140.776.71 - Statistical Computing/project/Project 2/biostats776-Project2")
require(tidyverse)
```


# Part 1: Fun with functions

In this part, we are going to practice creating functions.

### Part 1A: Exponential transformation 
The exponential of a number can be written as an infinite series expansion of the form
$$
\exp(x) = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots
$$
Of course, we cannot compute an infinite series by the end of this term and so we must truncate it at a certain point in the series. The truncated sum of terms represents an approximation to the true exponential, but the approximation may be usable.

Write a function that computes the exponential of a number using the truncated series expansion. The function should take two arguments:

* `x`: the number to be exponentiated

* `k`: the number of terms to be used in the series expansion beyond the constant 1. The value of `k` is always $\geq 1$.

For example, if $k = 1$, then the `Exp` function should return the number $1 + x$. If $k = 2$, then you should return the number $1 + x + x^2/2!$.

* You can assume that the input value `x` will always be a *single* number. 

* You can assume that the value `k` will always be an integer $\geq 1$. 

* Do not use the `exp()` function in R.

* The `factorial()` function can be used to compute factorials.


```{r}
Exp <- function(x, k) {
           sum(sapply(c(0:k), function(t) x^t/factorial(t)))
}
```


### Part 1B: Sample mean and sample standard deviation

Next, write two functions called `sample_mean()` and `sample_sd()` that takes as input a vector of data of length $N$ and calculates the sample average and sample standard deviation for the set of $N$ observations. 

$$
\bar{x} = \frac{1}{N} \sum_{i=1}^n x_i
$$
$$
s = \sqrt{\frac{1}{N-1} \sum_{i=1}^N (x_i - \overline{x})^2}
$$

* You can assume that the input value `x` will always be a *vector* of numbers of length $N$. 

* Do not use the `mean()` and `sd()` functions in R.

```{r}
sample_mean <- function(x) {
                   sum(x)/length(x)
}
sample_sd <- function(x) {
                 sqrt(sum(sapply(x, function(t) (t - sum(x)/length(x))^2))/(length(x) - 1))
}
```


### Part 1C: Confidence intervals

Next, write a function called `calculate_CI()` that:

1. Has two inputs to the `calculate_CI()` function. First, it should take as input a vector of data of length $N$. Second, the function should also have a `conf` ($=1-\alpha$) argument that allows the confidence interval to be adapted for different $\alpha$.


2. Calculates a confidence interval (CI) (e.g. a 95% CI) for the estimate of the mean in the population.


3. Returns a named vector of length 2, where the first value is the `lower_bound`, the second value is the `upper_bound`.


```{r}
calculate_CI <- function(x, conf) {
                    mean <- sample_mean(x)
                    sd_mean <- sample_sd(x)/sqrt(length(x))
                    t_score = qt(p = (1 - conf)/2, df = length(x) - 1, lower.tail = FALSE)
                    return(c(mean - t_score*sd_mean, mean + t_score*sd_mean))
}
```


Checking code:


```{r}
x <- c(rnorm(100))

print("# Using my function `calculate_CI`")
calculate_CI(x, conf = 0.95)

print("# Using `confint` function in {base}")
dat = data.frame(x=x)
fit <- lm(x ~ 1, dat)
confint(fit, level=0.95)
```




# Part 2: Wrangling data

In this part, we will practice our wrangling skills with the tidyverse that we learned about in module 1. 

### Data 

The two datasets for this part of the assignment comes from [TidyTuesday](https://www.tidytuesday.com). 
Specifically, we will use the following data from January 2020, which I have provided for you below:  

```{r, eval=FALSE}
tuesdata <- tidytuesdayR::tt_load('2020-01-07')
rainfall <- tuesdata$rainfall
temperature <- tuesdata$temperature
```

**Note**: A useful way to avoid re-downloading data is to write code to check to see if those files already exist using and `if()` statement: 

```{r, message=FALSE}
if(!file.exists(("./data/tuesdata_rainfall.RDS"))){
    tuesdata <- tidytuesdayR::tt_load('2020-01-07')
    rainfall <- tuesdata$rainfall
    temperature <- tuesdata$temperature
  
    # save the files to RDS objects
    saveRDS(tuesdata$rainfall, file= "./data/tuesdata_rainfall.RDS")
    saveRDS(tuesdata$temperature, file= "./data/tuesdata_temperature.RDS")
}
```

**Note** the above code will only run if it cannot find the path to the `tuesdata_rainfall.RDS` on your computer. Then, we can just read in these files every time we knit the R Markdown, instead of redownloading them every time. 

```{r, eval=TRUE, message=FALSE}
rainfall <- readRDS("./data/tuesdata_rainfall.RDS")
temperature <- readRDS("./data/tuesdata_temperature.RDS")
```

Now we can look at the data with `glimpse()`

```{r,message=FALSE}
require(tidyverse)
glimpse(rainfall)
glimpse(temperature)
```

If we look at the [TidyTuesday github repo](https://github.com/rfordatascience/tidytuesday/tree/master/data/2020#2020-data) from 2020, we see this dataset contains temperature and rainfall data from Australia.

Here is a data dictionary for what all the column names mean: 

- https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-01-07/readme.md#data-dictionary

### Tasks 

Using the `rainfall` and `temperature` data, perform the following steps and create a new data frame called `df`: 

1. Start with `rainfall` dataset and drop any rows with NAs. 
2. Create a new column titled `date` that combines the columns `year`, `month`, `day` into one column separated by "-". (e.g. "2020-01-01"). This column should not be a character, but should be recognized as a date. (**Hint** check out the `ymd()` function in `lubridate` R package). You will also want to add a column that just keeps the `year`. 
3. Using the `city_name` column, convert the city names (character strings) to all upper case. 
4. Join this wrangled rainfall dataset with the `temperature` dataset such that it includes only observations that are in both data frames. (**Hint** there are two keys that you will need to join the two datasets together). (**Hint**: If all has gone well thus far, you should have a dataset with 83,964 rows and 13 columns). 

```{r}
# Add your solution here
```


### Notes

* You may need to use functions outside these packages to obtain this result, in particular you may find the functions `drop_na()` from `tidyr` and `str_to_upper()` function from `stringr` useful.

